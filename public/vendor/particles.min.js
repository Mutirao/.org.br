/* Minimal local particles.js-compatible implementation for offline use */
(function(){
  if (window.particlesJS) return; // avoid duplicate
  window.pJSDom = window.pJSDom || [];

  function rand(min,max){return Math.random()*(max-min)+min}
  function clamp(v,min,max){return v<min?min:(v>max?max:v)}
  function colorToRgba(c,a){
    // accepts hex like #RRGGBB or rgb/rgba or css color names (fallback to gray)
    try{
      if(/^#([0-9a-f]{3}){1,2}$/i.test(c)){
        let r=0,g=0,b=0;const s=c.slice(1);
        if(s.length===3){r=parseInt(s[0]+s[0],16);g=parseInt(s[1]+s[1],16);b=parseInt(s[2]+s[2],16);}else{r=parseInt(s.slice(0,2),16);g=parseInt(s.slice(2,4),16);b=parseInt(s.slice(4,6),16);}
        return `rgba(${r},${g},${b},${a})`;
      }
    }catch(_){}
    return `rgba(156,163,175,${a})`; // slate-400 fallback
  }

  function ParticlesInstance(container, params){
    this.container = container;
    this.params = params||{};
    this.canvas = document.createElement('canvas');
    this.canvas.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;';
    this.ctx = this.canvas.getContext('2d');
    this.container.appendChild(this.canvas);

    const p = this.params;
    const baseNum = (p.particles&&p.particles.number&&p.particles.number.value)||60;
    const colorValues = (p.particles&&p.particles.color&&p.particles.color.value)||['#9CA3AF'];
    const opacity = (p.particles&&p.particles.opacity&&p.particles.opacity.value)||0.5;
    const sizeVal = (p.particles&&p.particles.size&&p.particles.size.value)||3;
    const randomSize = (p.particles&&p.particles.size&&p.particles.size.random)===true;
    const move = (p.particles&&p.particles.move)||{};
    const speed = move.speed||1.2;
    const line = (p.particles&&p.particles.line_linked)||{};
    const lineEnable = line.enable!==false;
    const lineDist = line.distance||150;
    const lineColor = colorToRgba(line.color||'#9CA3AF', line.opacity==null?0.35:line.opacity);
    const lineWidth = line.width==null?1:line.width;

    this.particles = [];
    this.colorValues = colorValues;
    this.opacity = opacity;
    this.sizeVal = sizeVal;
    this.randomSize = randomSize;
    this.speed = speed;
    this.lineEnable = lineEnable; this.lineDist=lineDist; this.lineColor=lineColor; this.lineWidth=lineWidth;

    this.resize = () => {
      const rect = this.container.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio||1);
      this.canvas.width = Math.floor(rect.width*dpr);
      this.canvas.height = Math.floor(rect.height*dpr);
      this.canvas.style.width = rect.width+'px';
      this.canvas.style.height = rect.height+'px';
      this.ctx.setTransform(dpr,0,0,dpr,0,0);
    };
    this.resize();

    const area = () => this.canvas.width*this.canvas.height;
    const densityFactor = 1; // keep simple, ignore density.value_area
    const count = Math.max(1, Math.floor(baseNum*densityFactor));
    for(let i=0;i<count;i++){
      this.particles.push({
        x: rand(0, this.canvas.width),
        y: rand(0, this.canvas.height),
        vx: rand(-1,1)*this.speed,
        vy: rand(-1,1)*this.speed,
        r: this.randomSize? rand(this.sizeVal*0.5, this.sizeVal*1.5): this.sizeVal,
        c: this.colorValues[Math.floor(rand(0,this.colorValues.length))]
      });
    }

    this._raf = null;
    this._loop = () => {
      const ctx = this.ctx; const w=this.canvas.width; const h=this.canvas.height;
      ctx.clearRect(0,0,w,h);
      // update and draw particles
      for(const p of this.particles){
        p.x += p.vx; p.y += p.vy;
        if(p.x<0) p.x=w; else if(p.x>w) p.x=0;
        if(p.y<0) p.y=h; else if(p.y>h) p.y=0;
        ctx.beginPath();
        ctx.fillStyle = colorToRgba(p.c, this.opacity);
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
      }
      // lines
      if(this.lineEnable){
        ctx.strokeStyle = this.lineColor; ctx.lineWidth = this.lineWidth;
        for(let i=0;i<this.particles.length;i++){
          for(let j=i+1;j<this.particles.length;j++){
            const a=this.particles[i], b=this.particles[j];
            const dx=a.x-b.x, dy=a.y-b.y; const d=Math.sqrt(dx*dx+dy*dy);
            if(d<=this.lineDist){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
          }
        }
      }
      this._raf = requestAnimationFrame(this._loop);
    };
    this._loop();

    this.destroy = () => {
      try{ cancelAnimationFrame(this._raf); }catch(_){ }
      window.removeEventListener('resize', this.resize);
      if(this.canvas && this.canvas.parentElement===this.container){ this.container.removeChild(this.canvas); }
    };

    window.addEventListener('resize', this.resize);

    // shim to mimic original api
    this.pJS = {
      canvas: { el: this.canvas },
      fn: { vendors: { destroypJS: this.destroy } }
    };
  }

  window.particlesJS = function(tag_id, params){
    const container = document.getElementById(tag_id);
    if(!container) return;
    const inst = new ParticlesInstance(container, params);
    window.pJSDom.push(inst);
    return inst;
  };
})();

